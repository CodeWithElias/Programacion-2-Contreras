//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TPROGRAMACION_2 *PROGRAMACION_2;
//---------------------------------------------------------------------------
__fastcall TPROGRAMACION_2::TPROGRAMACION_2(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TPROGRAMACION_2::SALIDAENTRADA2Click(TObject *Sender)
{
salida->Caption=entrada->Text;
}
//---------------------------------------------------------------------------

	//SUMA DE LOS DIGITOS DE UN NUMERO
byte sumadig(Cardinal x){
  byte s;

	 if (x<10) { //caso base
		s=x;
	 }
	 else{   //caso general
		s=sumadig(x/10);
		s=s+x%10;
	 }
  return s;
}


void __fastcall TPROGRAMACION_2::SUMADELOSDIGNUM1Click(TObject *Sender)
{
salida->Caption=sumadig(StrToInt(entrada->Text));
}
//---------------------------------------------------------------------------

	//SUMA DE LOS DIGITOS PRIMOS DE UN NUMERO
byte sumaDPrimos(Cardinal x){
  byte s;

	 if (x<10) { //caso base
		if ((x==1)|(x==2)|(x==5)|(x==3)|(x==7)) {
			s=x;
		}
	 }
	 else{   //caso general
		s=sumaDPrimos(x/10);
		if ((x%10==1)|(x%10==2)|(x%10==5)|(x%10==3)|(x%10==7)) {
			s=s+x%10;
		}

	 }
  return s;
}

void __fastcall TPROGRAMACION_2::SUMADIGPRIMOS1Click(TObject *Sender)
{
salida->Caption=sumaDPrimos(StrToInt(entrada->Text));
}
//---------------------------------------------------------------------------

    //MUESTRA EL DIGITO MAYOR EN UN NUMERO
byte digmayor(Cardinal x){
byte s;
	if (x<10) { // caso base
		s=x;
	}
	else{ //caso general
		s=digmayor(x/10);
		if (x%10>s) {
			s=x%10;
		}
	}
  return s;
}

void __fastcall TPROGRAMACION_2::DIGITOMAYOR1Click(TObject *Sender)
{
salida->Caption=digmayor(StrToInt(entrada->Text));
}
//---------------------------------------------------------------------------

		//MOVER EL DIGITO MAYOR DE UN NUMERO AL FINAL DEL MISMO NUMERO
			 //modificar
void MayorFinal(Cardinal &x){
	if (x>10) {
		byte y=x%10;
		x=x/10;
		MayorFinal(x);
		if (x%10<y) {
            x=x*10+y;
		}
	}
}

void __fastcall TPROGRAMACION_2::MAYORNUMFINAL1Click(TObject *Sender)
{
Cardinal x=StrToInt(entrada->Text);
MayorFinal(x);
salida->Caption=x;
}
//---------------------------------------------------------------------------

			 //ELIMINAR DIGITO DE UN NUMERO
void DeleteDig(Cardinal &x, byte d){
	if (x<10) {    //caso base
		if (x==d) {
		x=x/10;
		}
	}
	else {  //caso general
		byte c=x%10;
		x=x/10;
		DeleteDig(x,d);
		if (c!=d){
		x=x*10+c;
		}
	}
}

void __fastcall TPROGRAMACION_2::ELIMINARDIGNUMERO1Click(TObject *Sender)
{
byte d=StrToInt(digito->Text);
Cardinal x=StrToInt(entrada->Text);
DeleteDig(x,d);
salida->Caption=x;
}
//---------------------------------------------------------------------------

		//PROCESO PARA ORDENAR UN NUMERO
void Ordenar( Cardinal &x){

}
void __fastcall TPROGRAMACION_2::ORDENARUNNUMERO1Click(TObject *Sender)
{
Cardinal x=StrToInt(entrada->Text);
Ordenar(x);
salida->Caption=x;
}
//---------------------------------------------------------------------------

			  //ELEVAR UN NUMERO A UNA POTENCIA
float Potencia(float x, byte n){
 float p;
 if ((x==0)&&(n==0)) {
	throw new Exception ("Error: datos no válidos");
 }
 else{
	 if (n==0) { //caso base
		p=1;
	 }
	 else{ //caso general
		p=Potencia(x,n-1)*x;
	 }
 }
 return p;
}

void __fastcall TPROGRAMACION_2::POTENCIA1Click(TObject *Sender)
{
salida->Caption=FloatToStr(Potencia(StrToFloat(entrada->Text),StrToInt(digito->Text)));
}
//---------------------------------------------------------------------------

			  //CANTIDAD DE VOCALES DE UNA CADENA

bool EsVocal(char c){
AnsiString voc="aeiuoAEIOUÁÉÍÓÚáéíóú";
return voc.Pos(c)>0;
}

byte CantVocales(AnsiString x){
 byte c;
	 if (x=="") {  //caso base
		c=0;
	 } else{   // caso general
		char a=x[1];
		x.Delete(1,1);
		c=CantVocales(x);
		if (EsVocal(a)) {
			c++;
		}
	 }
 return c;
}

void __fastcall TPROGRAMACION_2::CANTVOCALES1Click(TObject *Sender)
{
salida->Caption=CantVocales(entrada->Text);
}
//---------------------------------------------------------------------------

	 //FUNCION QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO MENOS EL ULTIMO"
AnsiString Inverso1(AnsiString x){
AnsiString y;
byte n=x.Length();
	if (x=="") { //caso base
		y="";
	} else{  //caso general
		char c=x[n];
		x.Delete(n,1);
		y=Inverso1(x);
		y=AnsiString(c)+y;
	}
return y;
}

void __fastcall TPROGRAMACION_2::INVERSO11Click(TObject *Sender)
{
salida->Caption=Inverso1(entrada->Text);
}
//---------------------------------------------------------------------------

	 //FUNCION QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO MENOS EL PRIMERO
AnsiString Inverso2(AnsiString x){
AnsiString y;
byte n=x.Length();
	if (x=="") { //caso base
		y="";
	} else{  //caso general
		char c=x[1];
		x.Delete(1,1);
		y=Inverso2(x);
		y=y+AnsiString(c);
	}
return y;
}

void __fastcall TPROGRAMACION_2::INVERSO21Click(TObject *Sender)
{
salida->Caption=Inverso2(entrada->Text);
}
//---------------------------------------------------------------------------

void __fastcall TPROGRAMACION_2::Button1Click(TObject *Sender)
{
vector->ColCount=StrToInt(fila->Text);
}
//---------------------------------------------------------------------------

			 //SUMA DE LOS ELEMENTOS DE UN VECTOR "CON PARAMETRO N"
int Suma(TStringGrid *v, byte n){
int s;
	if (n==0) {   //caso base
	s=0;
	} else{   //caso general
		s=Suma(v,n-1)+StrToInt(v->Cells[n-1][0]);
	}
return s;
}


void __fastcall TPROGRAMACION_2::SUMA1Click(TObject *Sender)
{
salida->Caption=Suma(vector,vector->ColCount);
}
//---------------------------------------------------------------------------

			 //SUMA DE LOS ELEMENTOS DE UN VECTOR "CON PARAMETRO A Y B"

int Suma1(TStringGrid *v, int a, int b){
int s ; byte n=b-a+1;
	if (n==0) { //caso base
		s=0;
	} else {  //caso general
		s=Suma1(v,a+1,b)+StrToInt(v->Cells[a][0]);
	}
return s;
}

void __fastcall TPROGRAMACION_2::SUMA21Click(TObject *Sender)
{
salida->Caption=Suma1(vector,0,vector->ColCount-1);
}
//---------------------------------------------------------------------------

	//FUNCION QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO MENOS 2 PRIMEROS"

 AnsiString Inverso3(AnsiString x){
   AnsiString y;
   byte n=x.Length();
   if (n<2) { //caso base
	  y=x;
   } else { //caso general
	   char a=x[1];
	   char b=x[2];
	   x.Delete(1,2);
	   y=Inverso3(x);
	   y=y+AnsiString(b)+AnsiString(a);
   }
   return y;
 }

void __fastcall TPROGRAMACION_2::INVERSO31Click(TObject *Sender)
{
salida->Caption=Inverso3(entrada->Text);
}
//---------------------------------------------------------------------------

	   //BUSQUEDA BINARIA (vector ordenado  CON PARAMETROS a y b
bool BusquedaBinaria(TStringGrid *v,int x, byte a, byte b){
  bool esta; //variable de salida
  byte n=b-a+1; //variable de recurcion
	if (n==0) { // 1er caso base
		esta=false;
	} else if (n==1) { // 2do caso base
			  esta=x==StrToInt(v->Cells[a][0]);
		   } else {  //  caso general
			   byte c=(a+b)/2;
			   if (x==StrToInt(v->Cells[c][0])) {
				   esta=true;
			   } else if (x<StrToInt(v->Cells[c][0])) {
					  esta=BusquedaBinaria(v,x,a,c-1);
					  }  else{
							 esta=BusquedaBinaria(v,x,c+1,b);
							 }
		   }
	return esta;
}

void __fastcall TPROGRAMACION_2::BUSQUEDABINARIA1Click(TObject *Sender)
{
bool h=BusquedaBinaria(vector,StrToInt(digito->Text),0,vector->ColCount-1);
if (h) {
	salida->Caption="Si Está";
} else{
	  salida->Caption="No Está";
	  }
}
//---------------------------------------------------------------------------

	//FUNCION QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO MENOS 2 PRIMEROS"

 AnsiString Inverso4(AnsiString x){
   AnsiString y;
   byte n=x.Length();
   if (n<2) { //caso base
	  y=x;
   } else { //caso general
	   byte z=x.Length();
	   char a=x[z];
	   char b=x[z-1];
	   x.Delete(z-1,2);
	   y=Inverso4(x);
	   y=AnsiString(a)+AnsiString(b)+y;
   }
   return y;
 }
void __fastcall TPROGRAMACION_2::INVERSO41Click(TObject *Sender)
{
salida->Caption=Inverso4(entrada->Text);
}
//---------------------------------------------------------------------------

//FUNCION QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO MENOS EL PRIMERO Y EL ULTIMO

 AnsiString Inverso5(AnsiString x){
   AnsiString y;
   byte n=x.Length();
   if (n<2) { //caso base
	  y=x;
   } else { //caso general
	   char a=x[1];
	   char b=x[n];
	   x.Delete(n,1);
	   x.Delete(1,1);
	   y=Inverso5(x);
	   y=AnsiString(b)+y+AnsiString(a);
   }
   return y;
 }

void __fastcall TPROGRAMACION_2::INVERSO51Click(TObject *Sender)
{
salida->Caption=Inverso5(entrada->Text);
}
//---------------------------------------------------------------------------

//PROCEDIMIENTO QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO IZQUIERDA MAS CORTA"

void Inverso6(AnsiString &x)
{byte n=x.Length();
 if (n>=2) {   //caso general
   byte p=n/2+1;
   AnsiString y=x.SubString(p,n-n/2);
   x.Delete(p,n-n/2);
   Inverso6(x);
   Inverso6(y);
   x=y+x;
   }
}

void __fastcall TPROGRAMACION_2::INVERSO61Click(TObject *Sender)
{
AnsiString x=entrada->Text;
Inverso6(x);
salida->Caption=x;
}
//---------------------------------------------------------------------------

//PROCEDIMIENTO QUE DEVUELVA EL INVERSO DE UNA CADENA "TIPO DERECHA MAS CORTA"

void Inverso7(AnsiString &x)
{byte n=x.Length();
 if (n>=2) {     //caso general
   byte p=n/2;
   AnsiString y=x.SubString(1,p);
   x.Delete(1,p);
   Inverso7(x);
   Inverso7(y);
   x=x+y;
   }
}
void __fastcall TPROGRAMACION_2::INVERSO71Click(TObject *Sender)
{
AnsiString x=entrada->Text;
Inverso7(x);
salida->Caption=x;
}
//---------------------------------------------------------------------------

